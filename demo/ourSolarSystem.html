
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.geo - globe</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		
		<!-- ------ Custom Shader Code for atmospheric glow ------ -->
		<script id="vertexShaderAtmosphere" type="x-shader/x-vertex">
		varying vec3 vNormal;
		void main() 
		{
		    vNormal = normalize( normalMatrix * normal );
		    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}
		</script>

		<!-- fragment shader a.k.a. pixel shader -->
		<script id="fragmentShaderAtmosphere" type="x-shader/x-vertex"> 
		uniform float c;
		uniform float p;
		varying vec3 vNormal;
		// uniform sampler2D uTex;
		void main() 
		{
			float intensity = sqrt(pow( c - dot( vNormal, vec3( 1.0, 1.0, 1.0 ) ), p )); 
			gl_FragColor = vec4(1.0,0.0,0.0,0.08) * intensity ;
			// texture2D(uTex, vec2(vNormal[0], vNormal[1]))
		}
		</script>
	
	
	
	
	
	
	
	
	
		<script id="sunSurfaceVertexShader" type="x-shader/x-vertex">
 

		vec3 mod289(vec3 x)
		{
		  return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 mod289(vec4 x)
		{
		  return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 permute(vec4 x)
		{
		  return mod289(((x*34.0)+1.0)*x);
		}

		vec4 taylorInvSqrt(vec4 r)
		{
		  return 1.79284291400159 - 0.85373472095314 * r;
		}

		vec3 fade(vec3 t) {
		  return t*t*t*(t*(t*6.0-15.0)+10.0);
		}

		// Classic Perlin noise
		float cnoise(vec3 P)
		{
		  vec3 Pi0 = floor(P); // Integer part for indexing
		  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
		  Pi0 = mod289(Pi0);
		  Pi1 = mod289(Pi1);
		  vec3 Pf0 = fract(P); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);

		  vec4 gx0 = ixy0 * (1.0 / 7.0);
		  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		  vec4 gx1 = ixy1 * (1.0 / 7.0);
		  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);

		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}

		// Classic Perlin noise, periodic variant
		float pnoise(vec3 P, vec3 rep)
		{
		  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
		  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
		  Pi0 = mod289(Pi0);
		  Pi1 = mod289(Pi1);
		  vec3 Pf0 = fract(P); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);

		  vec4 gx0 = ixy0 * (1.0 / 7.0);
		  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		  vec4 gx1 = ixy1 * (1.0 / 7.0);
		  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);

		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}
 
		varying vec2 vUv;
		varying float noise;
		uniform float time;
 
		float turbulence( vec3 p ) {
		    float w = 100.0;
		    float t = -.5;
		    for (float f = 1.0 ; f <= 10.0 ; f++ ){
		        float power = pow( 2.0, f );
		        t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
		    }
		    return t;
		}
 
		void main() {
 
		    vUv = uv;
 
		    // add time to the noise parameters so it's animated
		    noise = 10.0 *  -.10 * turbulence( 1.0 * normal + time );
		    float b = 2.0 * pnoise( 0.25 * position + vec3( 2.0 * time ), vec3( 100.0 ) );
		    float displacement = - noise + b;
     
		    vec3 newPosition = position + normal * (displacement/2.0);
		    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
 
		}
		</script>
	



		<script id="sunSurfaceFragmentShader" type="x-shader/x-fragment">
	
			varying vec2 vUv;
			varying float noise;
			uniform sampler2D surface;
 
			void main() {
 
			    vec4 color = texture2D( surface, vUv );
 
			    gl_FragColor = vec4( color.rgb, 1.0 );
 
			}   
		</script>
	




	
		<script id="burningSunFragmentShader" type="x-shader/x-fragment">
	
		uniform float time;
		varying vec2 vUv;
 
		void main(void) 
		{
			vec2 p = -.5 + gl_FragCoord.xy / vUv.xy;
			p.x *= vUv.x/vUv.y;
	
			float color = 3.0 - (3.*length(2.*p));
	
			vec3 coord = vec3(cos(atan(p.x,p.y))/6.2832+.5, length(p)*.4, .5);
	
			for(int i = 2; i <= 7; i++)
			{
				float power = (pow(3.0, float(i)));
		
				vec3 uv = coord + vec3(0.,-time*.05, time*.01);
				float res = power*2.0;
		
				const vec3 s = vec3(1e0, 1e2, 1e4);
				uv *= res;
				vec3 uv0 = floor(mod(uv, res))*s;
				vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;
		
				vec3 f = fract(uv); f = f*f*(3.0-2.0*f);
		
				vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
					      uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);
		
				vec4 r = fract(sin(v*1e-3)*1e5);
				float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
		
				r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);
				float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
		
				float snoise = asin(mix(r0, r1, f.z)*2.-1.0);
		
				color += (1.5 / power) * atan(log(log(snoise)));
			}
		
			gl_FragColor = vec4( color * vUv.x, pow(max(color,0.),2.)*0.4* vUv.y, pow(max(color,0.),3.)*0.15 , 1.0);
		}
	
		</script>
	






		<script id="burningSunVertexShader" type="x-shader/x-vertex">
		varying vec2 vUv;
		// 
		// uniform float delta;
		// 
		// uniform float scale;
		// 
		// uniform float alpha;
		// 


		void main()

		{

		    vUv = uv;

		    vec3 p = position;
		    // 
		    // p.z += sin(2.0 * p.y + delta) * 5.0;
		    // 
		    // p.z += cos(2.0 * p.z + delta / 2.0) * 5.0;
		    // 
		    // p.z += cos(2.0 * p.x + delta) * 5.0;
		    // 
		    // p.x += sin(p.y + delta / 2.0) * 10.0;

		    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );

		    gl_Position = projectionMatrix * mvPosition;

		}
		</script>
	
		<script id="planetSurfaceFragmentShader" type="x-shader/x-fragment">
	
			varying vec2 vUv;
			uniform sampler2D skin;
			uniform sampler2D depth;
 
			void main() {
 
			    vec4 color = texture2D( skin, vUv );
 
			    gl_FragColor = vec4( color.rgb, 1.0 );
 
			}   
		</script>
	
	
	
	
	
	
	
	
		<script id="planetSurfaceVertexShader" type="x-shader/x-vertex">

		varying vec2 vUv;
		uniform sampler2D skin;
		uniform sampler2D depth;
	 	uniform float scale;
	
		void main() {
 
		    vUv = uv;
			vec4 dv = texture2D(depth, uv.xy);
			float df = (dv.x + dv.y + dv.z) / (scale * 200.0);
			// newVertexPos = vec4(normalize(position) * df * 1.0) + vec4 (position, 1.0);
		    // add time to the noise parameters so it's animated
		    // noise = 10.0 *  -.10 * turbulence( 1.0 * normal + time );
		    // float b = 15.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );
		    // float displacement = - noise + b;
     
		    // vec3 newPosition = position + normal * (displacement/2.0);
		    gl_Position = projectionMatrix * modelViewMatrix * (vec4( normalize(position) * df * 1.0, 1.0) + vec4 (position * 2.0, 1.0));
 
		}
		</script>

		<script src="js/libs/three.min.js"></script>

		<script src="js/libs/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>


		<script src="js/libs/three.geo.min.js"></script>
		<script src="js/three.solarsystem.min.js"></script>
		<script src="js/solarSystemData.js"></script>
		
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer, ourSolarSystem;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 22000 );

				camera.position.z = 18000;
				
				scene = new THREE.Scene();


				var light, object;

				scene.add( new THREE.AmbientLight( 0x404040 ) );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1, 0 );
				scene.add( light );






				ourSolarSystem = new THREE.SolarSystem(solarSystemData, scene);
				


				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}
			
			var counter = 0;
			
			function render() {

				ourSolarSystem.update();

				camera.lookAt( ourSolarSystem.star.position );


				renderer.render( scene, camera );

			}

		</script>
		
		

	</body>
</html>

THREE.SolarSystem = function (data, scene) {

	this.data = data;
	
	this.star = this.buildStar();
	
	this.starLight = new THREE.SolarSystem.StarLight(this.star);
	
	
	this.drawPlanetOrbits();

		
	this.planets = this.buildPlanets();
	
	this.scene = scene;
	this.scene.add(this.star);

};

THREE.SolarSystem.prototype = {
	
	getActivePlanet: function () {
		var renderedPlanets = this.planets;
		for (var planet in renderedPlanets) {
			if (renderedPlanets.hasOwnProperty(planet)) {
				if (renderedPlanets[planet].isActive) {
					return renderedPlanets[planet];
				}
			}
		}
	},
	
	setActivePlanet: function (planetName) {

		for (var planet in this.planets) {
			this.planets[planet].isActive = false;
		}

		this.planets[planetName].isActive = "true";
		

		
		var cameraPosition = {
			x: this.planets[planetName].mesh.position.x + (this.planets[planetName].mesh.radius * 4),
			y: this.planets[planetName].mesh.position.y,
			z: this.planets[planetName].mesh.position.z + (this.planets[planetName].mesh.radius * 4)
		}
		
		return cameraPosition;

	},
	
	// Update the position of the planets and the rotation of the star.
	update: function () {
	
	
		this.sunShader.uniforms[ 'time' ].value = .00025 * ( new Date() );
						
		var planetIsActive = false;
		var renderedPlanets = this.planets;
		for (var planet in renderedPlanets) {
			if (renderedPlanets.hasOwnProperty(planet)) {
				if (renderedPlanets[planet].isActive) {
				
					planetIsActive = true;
					renderedPlanets[planet].update();
				}
			}
		}
				
				
		for (var planet in renderedPlanets) {
		
			if (renderedPlanets.hasOwnProperty(planet)) {
			
				if (!planetIsActive) {
				
					renderedPlanets[planet].updatePosition();

				}
			}
		
		}
	
		// this.star.rotation.y += 0.001;
	
	},
	// Build the main star.
	buildStar: function () {
		
		var texture = THREE.ImageUtils.loadTexture(this.data.sun.representation.texture);
		var shaderMaterial = new THREE.ShaderMaterial( {
 
		    uniforms: { 
		        surface: { // texture in slot 0, loaded with ImageUtils
		            type: "t", 
		            // value: 0, 
		            value: texture
		        },
		        time: { // float initialized to 0
		            type: "f", 
		            value: 0.0 
		        }
		    },
		    vertexShader: document.getElementById( 'sunSurfaceVertexShader' ).textContent,
		    fragmentShader: document.getElementById( 'sunSurfaceFragmentShader' ).textContent
     
		} );
		
		this.sunShader = shaderMaterial;
		
		
		var sun = THREE.SolarSystem.PlanetBuilder.build({
			radius: this.data.sun.radius * 10,
			resolution: 128,
			mapImage: texture,
			bumpMap: THREE.ImageUtils.loadTexture(this.data.sun.representation.bumpMap, undefined, function () {}),
			atmosphereMaterial: new THREE.ShaderMaterial( 
			{
			    uniforms:       
				{ 
					"c":   { type: "f", value: 0.1 },
					"p":   { type: "f", value: 1.0 },
				},
				vertexShader:   document.getElementById( 'vertexShaderAtmosphere'   ).textContent,
				fragmentShader: document.getElementById( 'fragmentShaderAtmosphere' ).textContent,
				transparent:true
			}   )
		});
		
		sun.material = shaderMaterial;
		return sun;
			
	},
	// Build the varied planets of the solar system.
	buildPlanets: function () {
		
		// Local planet cache to return from this method.
		var planets = {};
		
		for (var i = 0, len = this.data.planets.length; i < len; i += 1) {
		
			var planetData = this.data.planets[i];
			var texture;
			if (planetData.representation.texture.indexOf(".dds") > -1) {
				texture = THREE.ImageUtils.loadCompressedTexture(planetData.representation.texture, undefined, function () {})
			}
			else {
				texture = THREE.ImageUtils.loadTexture(planetData.representation.texture, undefined, function () {})
			}

			var buildConfiguration = {
				radius: planetData.radius * 300,
				resolution: 128,
				mapImage: texture,
			};
			
			
			
		
			if (planetData.representation.bumpMap) {
				buildConfiguration.bumpMap = THREE.ImageUtils.loadTexture(planetData.representation.bumpMap, undefined, function () {});
			}
			else {
				buildConfiguration.bumpMap = buildConfiguration.mapImage;
			}
		
			if (planetData.representation.textureOffset) {
				buildConfiguration.mapOffset = planetData.representation.textureOffset;
			}
			
			if (planetData.representation.depth) {
				
				var img = document.createElement(img);
				img.src = planetData.representation.depth.low;
				img.onload = function () {
					
					
					
				}.bind(this);
				
			}
			
		
			var planet = THREE.SolarSystem.PlanetBuilder.build(buildConfiguration);
		
			// planet.position.set(planetData.distance, 0, 0);
		
			planet.coordinates = {
				phi: planetData.coordinates.phi,
				lambda: planetData.coordinates.lambda,
				radius: planetData.coordinates.radius
			};
		
			this.star.addGeoSymbol(planet);

			
			planets[planetData.name] = new THREE.SolarSystem.Planet({
				mesh: planet,
				data: planetData,
				isActive: false
			});
		
			planetData.orbitLine.lookAt(planet.position);
			
			
		}
		
		return planets;
		
	},

	// Draw the planets orbits
	//
	// TODO account for ecliptic plane orientation
	drawPlanetOrbits: function (star) {
		for (var i = 0, len = this.data.planets.length; i < len; i += 1) {
			// if (i == len-1) {
			// 
			// 		
			// }
			(function (planet) {
		
				var resolution = 1000;
				var amplitude = planet.coordinates.radius;
				var size = 360 / resolution;

				var geometry = new THREE.Geometry();
				var material = new THREE.LineBasicMaterial( { color: 0x0099FF, opacity: 0.2, depthTest: true, blending:THREE.AdditiveBlending, transparent:true} );
				for(var i = 0; i <= resolution; i++) {
				    var segment = ( i * size ) * Math.PI / 180;
				    geometry.vertices.push( new THREE.Vector3( Math.cos( segment ) * amplitude, 0, Math.sin( segment ) * amplitude ) );         
				}

				var line = new THREE.Line( geometry, material );
				// if (planet.name == "Earth" || planet.name == "Venus" || planet.name == "Mercury" || planet.name == "Mars") {
				// 	return;
				// }
				this.scene.add(line);
				planet.orbitLine = line;
		
			}(this.data.planets[i]))
		}		
	}
	
}


THREE.SolarSystem.Planet = function (config) {

	this.mesh = config.mesh;
	this.data = config.data;
	this.isActive = config.isActive;
	
	this.isNewlyActive = true;
	
	if (config.data.representation.texture.indexOf(".dds") > -1) {
		this.texture = THREE.ImageUtils.loadCompressedTexture(config.data.representation.texture, undefined, function () {})
	}
	else {
		this.texture = THREE.ImageUtils.loadTexture(config.data.representation.texture, undefined, function () {})
	}
	
	
};

THREE.SolarSystem.Planet.prototype = {
	
	update: function () {

		if (this.isNewlyActive) {

			this.isNewlyActive = false;
			
			this.renderExtras();
			
		}
	},
	
	renderExtras: function () {

		// if (this.data.name = "Earth") {
			MessageController.sendMessage("app-controller", "set-minimum-zoom-level", this.mesh.radius * 1.2);
			MessageController.sendMessage("app-controller", "set-minimum-zoom-level-reached-callback", this.swapToLOD.bind(this));
			
			this.loadDepthMap();
			
		// }
		
	},
	
	swapToLOD: function () {
		
	},
	
	loadDepthMap: function () {
		
		if (this.data.representation.bumpMap) {
			this.depthTexture = THREE.ImageUtils.loadTexture( this.data.representation.bumpMap, undefined, this.depthMapCallback.bind(this));			
		}
		else {
			this.depthTexture = THREE.ImageUtils.loadTexture( this.data.representation.texture, undefined, this.depthMapCallback.bind(this));			
		}

	},
	
	depthMapCallback: function (data, height, width) {
	
		var shaderMaterial = new THREE.ShaderMaterial( {

		    uniforms: { 
		        depth: { // texture in slot 0, loaded with ImageUtils
		            type: "t",
		            value: this.depthTexture
		        },
				scale: {
					type: "f",
					value: this.data.radius
				},
				skin: {
					type: "t",
					value: this.texture
				}
		    },
		    vertexShader: document.getElementById( 'planetSurfaceVertexShader' ).textContent,
		    fragmentShader: document.getElementById( 'planetSurfaceFragmentShader' ).textContent
 
		} );
	
		this.mesh.material = shaderMaterial;

		
	},

	updatePosition: function () {
		
	  	var orbit = 1/(this.data.orbitalPeriod.years*1 + (this.data.orbitalPeriod.days / 365)  + (this.data.orbitalPeriod.hours / 8760));

	  	var rotationPeriod = 1/(this.data.rotationPeriod.years*1 + (this.data.rotationPeriod.days / 365)  + (this.data.rotationPeriod.hours / 8760));

		this.mesh.rotation.y += rotationPeriod * 0.0000001;
		
	}
	
};
THREE.SolarSystem.StarLight = function (star) {
	
	this.star = star;
	
	this.textureFlare0 = THREE.ImageUtils.loadTexture( "textures/lensflare0.png" );
	this.textureFlare2 = THREE.ImageUtils.loadTexture( "textures/lensflare2.png" );
	this.textureFlare3 = THREE.ImageUtils.loadTexture( "textures/lensflare3.png" );

	

	this.addLight( 0.55, 0.9, 0.5, 5000, 0, -1000 );
	this.addLight( 0.08, 0.8, 0.5,    0, 0, -1000 );
	this.addLight( 0.995, 0.5, 0.9, 5000, 5000, -1000 );
	
};

THREE.SolarSystem.StarLight.prototype = {

	lensFlareUpdateCallback: function ( object ) {

		var f, fl = object.lensFlares.length;
		var flare;
		var vecX = -object.positionScreen.x * 2;
		var vecY = -object.positionScreen.y * 2;


		for( f = 0; f < fl; f++ ) {

			   flare = object.lensFlares[ f ];

			   flare.x = object.positionScreen.x + vecX * flare.distance;
			   flare.y = object.positionScreen.y + vecY * flare.distance;

			   flare.rotation = 0;

		}

		object.lensFlares[ 2 ].y += 0.025;
		object.lensFlares[ 3 ].rotation = object.positionScreen.x / 0.5 + THREE.Math.degToRad( 45 );

	},
	
	addLight: function ( h, s, l, x, y, z ) {

		var light = new THREE.PointLight( 0xffffff, 0.5, 4500 );
		light.color.setHSL( h, s, l );
		light.position.set( 0,0,0 );
		this.star.add( light );

		var flareColor = new THREE.Color( 0xffffff );
		flareColor.setHSL( h, s, l );

		var lensFlare = new THREE.LensFlare( this.textureFlare0, 100, 0.0, THREE.AdditiveBlending, flareColor );

		lensFlare.add( this.textureFlare2, 256, 0.0, THREE.AdditiveBlending );
		lensFlare.add( this.textureFlare2, 128, 0.0, THREE.AdditiveBlending );
		lensFlare.add( this.textureFlare2, 512, 0.0, THREE.AdditiveBlending );

		// lensFlare.add( this.textureFlare3, 60, 0.6, THREE.AdditiveBlending );
		// lensFlare.add( this.textureFlare3, 70, 0.7, THREE.AdditiveBlending );
		// lensFlare.add( this.textureFlare3, 120, 0.9, THREE.AdditiveBlending );
		// lensFlare.add( this.textureFlare3, 70, 1.0, THREE.AdditiveBlending );

		lensFlare.customUpdateCallback = this.lensFlareUpdateCallback.bind(this);
		lensFlare.position = this.star.position;

		this.star.add( lensFlare );

	}
	
};
THREE.SolarSystem.PlanetBuilder = {
	build: function (config) {
		
		config.resolution = config.resolution || 100;
		

		var maskGeometry = new THREE.SphereGeometry(config.radius, config.resolution, config.resolution);
		var maskMaterial = new THREE.MeshPhongMaterial({  depthTest: true });		

		maskMaterial.depthTest = true;
		maskMaterial.map = config.mapImage;

		if (config.bumpMap) {
			
			maskMaterial.bumpMap = config.bumpMap;

			maskMaterial.bumpScale = 1.5
			
		}
		else {
			
			maskMaterial.bumpMap = config.mapImage;

			maskMaterial.bumpScale = 1.5
		}
		
		maskMaterial.transparent = false;

		var planet = new THREE.GEO.SpatialMap(maskGeometry, maskMaterial);

		planet.setRadius(config.radius);
		

		if (config.atmosphereMaterial) {

			var mesh = new THREE.Mesh( maskGeometry.clone(), config.atmosphereMaterial );
			mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.0;

			planet.add(mesh);
		
			var mesh = new THREE.Mesh( maskGeometry.clone(), new THREE.MeshPhongMaterial( { color: 0x330000, opacity:0.01, transparent:true} ) );
			mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.0;
			mesh.receiveShadow = true;

			planet.add(mesh);
				
		}
		
		if (config.mapOffset) {
			planet.setTexturesEdgeLongitude(config.mapOffset);
		}


		return planet;
	},
	
	buildMoon: function (config) {
		
	}
};

